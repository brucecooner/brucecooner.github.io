<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/tr/html4/loose.dtd">
<html lang="en">
<head>
    <title>Make a Mandala</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="author" content="Bruce Cooner">
    <meta name="description" content="graphics tinkering">

    <!-- TODO: do we need type attributes here? -->
    <!-- TODO: can we push the dependencies into their dependent modules? (not easily) -->
    <link rel="stylesheet" type="text/css" href="mandalaStyles.css">
    <script src="libs/jquery-3.1.1.min.js"></script>
    <script src="libs/utility.js"></script>
    <script src="libs/myRangeInput.js"></script>
    <script src="libs/WatchedValue.js"></script>
    <script src="libs/debugDiv.js"></script>
    <script src="libs/fnc2d.js"></script>
    <script src="libs/docVisible.js"></script>

    <script src="graphicsCommands.js"></script>
    <script src="graphicsEngine.js"></script>

    <script src="colorJourney.js"></script>
    <script src="drawModeLines.js"></script>
    <script src="drawModeContinuous.js"></script>
    <script src="drawModeCircles.js"></script>
    <script src="drawModeCurves.js"></script>
    <script src="drawModeErase.js"></script>
    <script src="cursorEngine.js"></script>
    <script src="snapPointManager.js"></script>
    <script src="drawEngine.js"></script>
    <script src="mandala.js"></script>
    <!-- <link rel='shortcut icon' type='image/x-icon' href='/favicon.ico' /> -->
</head>
<!-- <body onload="onBodyLoad()" onresize="onBodyResize()"> -->
<body onresize="onBodyResize()">

   <!--
   TODO:
   BUGS:
   -mirroring busted with non-zero offset!!!
   -cancelled strokes don't re-render view
   -freeform mode line doesn't close when cursor snapped, hmmm...
   -bug where very short freeform strokes do not generate start snap point
   -FEATURES:
      -SNAP OBJECTS
         -snap GRID - doesn't really fit theme does it?
         -snap to lines?
         -snap to circles?
      -prettier help than notes div
      -confirm dialog on clear, or maybe undoing clears
      -how about a REdo?
      -color selection?
      -line width selection
      -draw mode specific config? (line width, eraser size, etc.)
      -guide opacity?
      -configurable color journey / switch to HSL
      -guide distance markers ?
      -line choices (size, shape, helix?, etc.)
   -TECH:
      -auto-init the mode selector
      -better way to view than giant base-64 string?
      -paths instead of lines? Or maybe variable point lines?
      -have continuous draw use paths
      -mandala can recreate from parameters
      -officially migrate to K&R brackets (grumble)
      -better way to trigger renders (pub/sub maybe?)
      -render command arrays with workers?
      -get handle on naming functions in mandala, general functionality
      -use library for event listening attach
   -LAYOUT:
   -->

   <script>

   const drawModeNames = ['freeform', 'curves', 'lines', 'circles']

   const notesLines = [
      'space : toggle draw mode',
      'u : undo',
      'x : clear',
      'm : mirror around guides',
      'g : show/hide petal guides',
      'h : show/hide half guides',
      'v : view (opens new winow)',
      '< >: halve/double guides',
      'left mouse: draw',
      'right mouse: cancel (some modes)',
      'ctrl(hold): snap (gray circles)',
   ]

   const drawingCanvasId = 'drawingCanvasId'
   const guidesCanvasId = 'guidesCanvasId'
   const cursorCanvasId = 'cursorCanvasId'
   // can hold some number of strokes so they can be undone before 'committing'
   // to the drawing canvas
   const strokeBufferCanvasId = 'strokeBufferCanvasId'

   // temprary-ish stuff, will try to animate at some point
   const scratchCanvasId = 'scratchCanvasId'

   const snapManagerStripeWidth = 50;
   const snapPointRadius = 5;

   // order in which canvases are created
   let canvasOrder = [ drawingCanvasId, strokeBufferCanvasId, guidesCanvasId, scratchCanvasId, cursorCanvasId ]

   // ==========================================================================
   const delayBeforeColorJourneyStart = 55
   const minColorJourneySpeed = 3
   const maxColorJourneySpeed = 60 * 3
   const defaultColorJourneyScale = 0.5

   // drawing
   var drawEngine = null
   var colorJourney = null
   var snapPointManager = null
   var tempSnapPointManager = null

   var tempSnapPoints = []

   // status
   // which petal of mandala cursor is on
   cursorCurrentPetal = null
   cursorCurrentNearestLine = null
   snapModeActive = false

   // --------------------------------------------------------------------------
   // returns color speed given a normalized scale value
   function getColorJourneySpeed(scale)
   { return minColorJourneySpeed + ((maxColorJourneySpeed-minColorJourneySpeed)*scale)}

   // --------------------------------------------------------------------------
   // receives:value-normalized speed of color speed transitions
   function setColorJourneySpeed(scale)
   {
      console.log(`setting color journey scale:${scale}`)
      colorJourney.setSpeed(getColorJourneySpeed(1 - scale))
   }

   // --------------------------------------------------------------------------
   function getClosestGuideGraphics()
   {
      let line = new fnc2d.Line(cursorCurrentNearestLine).scaleEq(100);
      let graphics = []
      graphics.push( GraphicsCommands.setDrawParameter('strokeStyle', '#FF0000'))
      graphics.push( GraphicsCommands.line(line.p1, line.p2))

      return graphics
   }

   // --------------------------------------------------------------------------
   function getSnapObjectGraphics()
   {
      let graphics = []
      if (snapModeActive)
      {
         graphics.push( GraphicsCommands.setDrawParameter('strokeStyle', '#DDDDDD') )

         snapPointManager.snapPoints.forEach( function(currentSnapPoint)
         {
            graphics.push( GraphicsCommands.circle(currentSnapPoint.center.x, currentSnapPoint.center.y, currentSnapPoint.radius, '#DDDDDD'))
         });

         tempSnapPointManager.snapPoints.forEach( function(currentSnapPoint)
         {
            graphics.push( GraphicsCommands.circle(currentSnapPoint.center.x, currentSnapPoint.center.y, currentSnapPoint.radius, '#DDDDDD'))
         });

         // graphics.push( GraphicsCommands.setDrawParameter('strokeStyle', '#AA0000') );
         // let i = 0;
         // for (i = 0; i <= 7; i += 1)
         // {
         //    let xCoord = i * snapManagerStripeWidth; // todo : magic number for snap stripe width, make const!
         //    graphics.push( GraphicsCommands.line( new fnc2d.Point(xCoord, -500), new fnc2d.Point(xCoord, 500) ));
         // }

         // if (drawEngine.currentSnapPoint)
         // {
         //    graphics.push( GraphicsCommands.setDrawParameter('strokeStyle', '#FF0000') )
         //    let center = drawEngine.currentSnapPoint.coords.translate(canvasOrigin)
         //
         //    graphics.push( GraphicsCommands.circle(   center.x,
         //                                              center.y,
         //                                              drawEngine.currentSnapPoint.radius, '#DDDDDD'))
         // }
      }

      return graphics
   }

   // --------------------------------------------------------------------------
   function getScratchGraphics()
   {
      let graphics = [ GraphicsCommands.clear() ]

      graphics.push( GraphicsCommands.setDrawParameter( 'translate', getDrawingCenter()));

      //graphics = graphics.concat( getClosestGuideGraphics() )
      graphics = graphics.concat( getSnapObjectGraphics() )

      return graphics
   }

   // --------------------------------------------------------------------------
   var menuDivIds = ['petalsConfigDivId', 'colorsConfigDivId']

   // --------------------------------------------------------------------------
   function showConfigMenu(menuDivId)
   {
      // console.log(`showMenu : ${menuDivId}`)
      var numDivs = $('.configDivClass').length
      // console.log(`num divs: ${numDivs}`)

      $('.configDivClass').each( function()
      {
         isShown = this.id == menuDivId

         $(this).toggleClass('visible', isShown)
         $(this).toggleClass('menu_transparent', !isShown)
      })
   }

   // --------------------------------------------------------------------------
   function dismissConfigMenus()
   {
      $('.configDivClass').each( function()
      {
         $(this).toggleClass('visible', false)
         $(this).toggleClass('menu_transparent', true)
      })
   }

   // --------------------------------------------------------------------------
   function resizeCanvases()
   {
      $('.dynamicCanvas').each( function()
      {
         this.width = this.clientWidth
         this.height = this.clientHeight
      })
   }

   // --------------------------------------------------------------------------
   // canvases
   // receives: config {canvasOrder }
   // --------------------------------------------------------------------------
   function createCanvases( config )
   {
      var canvasContainerEl = document.getElementById('canvasContainerId')

      // var left = `${canvasContainerEl.clientWidth / 2 - canvasSize / 2}px`
      // var top = `${canvasContainerEl.clientHeight / 2 - canvasSize / 2}px`

      config.canvasOrder.forEach( function(currentId)
      {
         $newCvs = $("<canvas></canvas>")
         $newCvs[0].id = currentId
         $newCvs.addClass('dynamicCanvas')
         $newCvs[0].width = window.innerWidth
         $newCvs[0].height = window.innerHeight

         $('#canvasContainerId').append($newCvs)
      })
   }

   // --------------------------------------------------------------------------
   // returns center coordinate of drawing canvas
   function getDrawingCenter()
   {
      let drawCanvas = getDrawCanvas()

      return new fnc2d.Point(drawCanvas.width / 2, drawCanvas.height / 2)
   }

   // ==========================================================================
   // buffer stuff
   // becomes an array of drawStroke's, graphics commands PLUS snap point names ?
   var strokeBuffer = []
   const strokeBufferSize = 25

   var allStrokesBuffer = []

   // --------------------------------------------------------------------------
   function undo()
   {
      let removedStroke = null

      if (strokeBuffer.length > 0)
      {
         removedStroke = strokeBuffer.splice( strokeBuffer.length - 1, 1)

         if (removedStroke[0].snapPoints)
         {
            snapPointManager.removeSnapPoints(removedStroke[0].snapPoints)
            // for (var currentPoint of removedStroke[0].snapPoints)
            // {
            //    console.log(`removing snap point ${currentPoint.name}`)
            // }
         }
      }

      renderStrokeBuffer(strokeBufferGraphicsEngine, true)
      scratchGraphicsEngine.render();

      debugDiv.add('strokeBuffer', `buffer len:${strokeBuffer.length}`)
   }

   // --------------------------------------------------------------------------
   // TODO: ugh, more dynamic canvas fetch!
   function getDrawCanvas()
   {
      return document.getElementById(drawingCanvasId)
   }
   function getInputCanvas()
   {
      // currently topmost one
      return document.getElementById(cursorCanvasId)
   }

   // --------------------------------------------------------------------------
   // searches for a snap point
   function findSnapPoint(point)
   {
      let foundPoint = null

      if (snapModeActive)
      {
         foundPoint = snapPointManager.getSnapPoint(point)

         if (null === foundPoint)
         {
            foundPoint = tempSnapPointManager.getSnapPoint(point)
         }
      }

      return foundPoint
   }

   // --------------------------------------------------------------------------
   function manageTempSnapPoints(point = null)
   {
      if (null !== point)
      {
         let points = mandala.reflectPoints(point)

         points.forEach( function(curPoint)
         {
            let currentPoint = tempSnapPointManager.addSnapPoint(curPoint, snapPointRadius)
            if (currentPoint)
            {
               tempSnapPoints.push(currentPoint)
            }
         })
      }
      else
      {
         tempSnapPointManager.removeSnapPoints(tempSnapPoints)
         tempSnapPoints = []
      }
   }

   // ----------------------------------------------------------
   // drawing
   // ---------------------------------------------------------
   function toCanvasSpace(point)
   {
      cvs = getDrawCanvas()
      return new fnc2d.Point(point).translate( cvs.width / 2, cvs.height / 2)
   }
   function toMandalaSpace(point)
   {
      cvs = getDrawCanvas()
      return new fnc2d.Point(point).translate(-1 * (cvs.width / 2), -1 * (cvs.height / 2))
   }

   // ---------------------------------------------------------
   function renderGuides()
   {
      commands = [ GraphicsCommands.clear() ]
      commands.push( GraphicsCommands.setDrawParameter('lineDash', [0,0]) )

      if ( mandala.drawGuides )
      {
         let drawCenter = getDrawingCenter()
         guideLength = drawCenter.delta(0,0).length() // note:distance to corner
         lines = mandala.renderGuides(guideLength)

         linesCommands = lines.guideLines.map( function(lineParams)
         {
            return GraphicsCommands.line( toCanvasSpace(lineParams.p1),
                                          toCanvasSpace(lineParams.p2) )
         })

         commands = commands.concat( linesCommands )

         commands.push(GraphicsCommands.quadraticCurve({x:0,y:0}, {x:400,y:0},{x:200,y:-50}))

         if (lines.halfGuideLines.length > 0)
         {
            linesCommands = lines.halfGuideLines.map( function(lineParams)
            {
               return GraphicsCommands.line( toCanvasSpace(lineParams.p1),
                                             toCanvasSpace(lineParams.p2) )
            })

            commands = commands.concat([ GraphicsCommands.setDrawParameter('lineDash', [5,3])] )
            commands = commands.concat( linesCommands )
         }
      }
      guidesGraphicsEngine.execute(commands)
   }

   // --------------------------------------------------------------------------
   // clears EVERYTHING
   function eraseAll()
   {
      outputGraphicsEngine.execute(GraphicsCommands.clear())
      strokeBufferGraphicsEngine.execute( GraphicsCommands.clear())
      allStrokesBuffer = []
      strokeBuffer = []

      snapPointManager.resetPoints()
      if (scratchGraphicsEngine)
      {
         scratchGraphicsEngine.render()
      }
   }

   // --------------------------------------------------------------------------
   // consolidates information needed to render a draw stroke in the mandala object
   function buildMandalaStroke(graphicsCommands, drawParameters, clearCanvas)
   {
      if (null === drawParameters)
      {
         drawParameters = {}
      }

      // if color not specified, add it here
      // if user color selection is added, it'd go here I guess
      if (!drawParameters.hasOwnProperty('strokeStyle'))
      {
         drawParameters.strokeStyle = '#000000'
      }

      // note that mandala keeps no knowledge of element/canvas sizes
      let canvasOrigin = getDrawingCenter()

      let mandalaState = mandala.getState()

      if (null !== mandalaState.mirrorLine)
      {
         let mirroredCommands = mandala.mirrorCommands(graphicsCommands, mandalaState.mirrorLine)
         graphicsCommands = mirroredCommands
      }

      return { commands:graphicsCommands,
               mandalaState:mandalaState,
               drawParameters: drawParameters,
               origin:canvasOrigin,
               clear:clearCanvas}
   }

   // --------------------------------------------------------------------------
   function renderStrokeBuffer(graphicsEngine, clearBefore)
   {
      if (clearBefore)
      {
         strokeBufferGraphicsEngine.execute(GraphicsCommands.clear())
      }

      strokeBuffer.forEach( function(currentStroke)
      {
         mandala.render(currentStroke.graphics, graphicsEngine, false)
      })
   }

   // --------------------------------------------------------------------------
   // graphicsCommands : [ {graphic command}, ... ]
   // snapPointCoords : [ point, ... ]
   function drawOutput(graphicsCommands, snapPointCoords = null)
   {
      let newStroke = buildMandalaStroke(graphicsCommands, {strokeStyle:'#000000'}, false)

      let newSnapPoints = []
      if (snapPointCoords)
      {
         for (currentPoint of snapPointCoords)
         {
            let reflectedPoints = mandala.reflectPoints(currentPoint)

            for (currentReflectedPoint of reflectedPoints)
            {
               newSnapPoint = snapPointManager.addSnapPoint(currentReflectedPoint, snapPointRadius)

               // test for rejection (means already a point there)
               if (newSnapPoint)
               {
                  newSnapPoints.push(newSnapPoint)
               }
            }
         }
         // testing...
         console.log(`stroke resulted in ${newSnapPoints.length} new snap points`)
      }


      // need to commit buffered render to draw canvas?
      if (strokeBuffer.length >= strokeBufferSize)
      {
         // if strokes are ejected FROM buffer, redraw it fully so there's no overdraw
         // with the draw canvas
         commitStroke = strokeBuffer.splice(0, 1)[0]
         mandala.render(commitStroke.graphics, outputGraphicsEngine)

         allStrokesBuffer.push(commitStroke.graphics)

         strokeBuffer.push({ graphics:newStroke, snapPoints:newSnapPoints })
         renderStrokeBuffer(strokeBufferGraphicsEngine, true)
      }
      else
      {
         strokeBuffer.push({ graphics:newStroke, snapPoints:newSnapPoints})
         // note : does not call for redraw, nothing was ejected from drawBuffer
         mandala.render(newStroke, strokeBufferGraphicsEngine, false)
      }

      debugDiv.add('strokeBuffer', `buffer len:${strokeBuffer.length}`)
   }

   // --------------------------------------------------------------------------
   // handles mandala/reflection concerns
   // receives:graphicsCommands : [ {graphic command}, ... ]
   function drawCursorOutput(graphicsCommands)
   {
      let renderObject = buildMandalaStroke(graphicsCommands, {strokeStyle:'#000000'}, true)

      // TODO : save object or something?

      // dispatch it to the mandala
      mandala.render(renderObject, cursorGraphicsEngine)
   }

   // -------------------------------------------------
   // returns : { petalNum:number, closestGuide:{p1:{x,y}, p2:{x,y}}}}
   function calcPetalNumAndClosestGuide(point)
   {
      // note : starting along -y no matter if petals are offset (this effectively
      // transforms petals into 'local' space, or offset == 0)
      let basis = new fnc2d.Line([0,0], [0,-1])

      // note : unrotating by petalsOffset so basis/delta are both at zero
      let delta = new fnc2d.Line([0,0], point.rotate(-mandala.petalsOffset * mandala.radiansPerPetal()))

      let angle = delta.angleTo(basis)
      if (delta.p2.x < 0)
      {
         angle = Math.PI + (Math.PI - angle)
      }

      // debugDiv.add('pmDelta', `pm_delta:${delta.str()}`)
      // debugDiv.add('pmAngle', `pm_angle:${angle}`)

      // which petals between?
      let petalNum = Math.floor(angle / mandala.radiansPerPetal())

      let closestGuideRotation = petalNum * mandala.radiansPerPetal() + (mandala.petalsOffset * mandala.radiansPerPetal())
      // is point past halfway point of petal?
      if ( angle > (petalNum * mandala.radiansPerPetal()) + (mandala.radiansPerPetal() / 2))
      {
         closestGuideRotation += mandala.radiansPerPetal()
      }
      let endPoint = new fnc2d.Point(0, -1).rotate(closestGuideRotation)

      let closestGuide = new fnc2d.Line([0,0], endPoint)

      // return petalNum
      return { petalNum, closestGuide }
   }

   // --------------------------------------------------------------------------
   // tell this module when draw cursor moves
   // receives: point{x,y} (in canvas space)
   function onCursorMove(point)
   {
      debugDiv.add('cursormove', `(main)cursor:${point.str()}`)

      let cursorAndGuide = calcPetalNumAndClosestGuide(point)

      cursorCurrentPetal = cursorAndGuide.petalNum
      cursorCurrentNearestLine = cursorAndGuide.closestGuide

      // debugDiv.add('curPetal', `cur_petal:${cursorCurrentPetal}`)

      if (mandala.mirrorGuides )
      {
         mandala.setMirrorLine( cursorAndGuide.closestGuide )
         debugDiv.add('mirrorLine1', `m. line p1:${mirrorLine.p1.x},${mirrorLine.p1.y}`)
         debugDiv.add('mirrorLine2', `m. line p2:${mirrorLine.p2.x},${mirrorLine.p2.y}`)
      }

      // TODO : this should be a function?
      if (scratchGraphicsEngine)
      {
         scratchGraphicsEngine.render()
      }

      renderCursorGraphics()

      debugDiv.add(`totalSnapPts`, `snap pts: ${snapPointManager.snapPoints.length}`)
      debugDiv.add(`lastSnapComp`, `last snap comp: ${snapPointManager.lastSearchPointComparisons}`)
      debugDiv.add(`totalTempSnapPts`, `tmp snap pts: ${tempSnapPointManager.snapPoints.length}`)
      debugDiv.add(`lastTempSnapComp`, `last tmp snap comp: ${tempSnapPointManager.lastSearchPointComparisons}`)
      debugDiv.add('snapModeActive', `snap active:${snapModeActive}`)
   }

   // --------------------------------------------------------------------------
   function renderCursorGraphics()
   {
      cursorGraphics = drawEngine.getCursorGraphics()
      drawCursorOutput(cursorGraphics)
   }

   // --------------------------------------------------------------------------
   // graphics engines TODO: don't particularly like this type name
   var cursorGraphicsEngine = null
   var outputGraphicsEngine = null
   var guidesGraphicsEngine = null
   var strokeBufferGraphicsEngine = null
   var scratchGraphicsEngine = null

   function initGraphicsEngines()
   {
      cursorGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getInputCanvas()})
      outputGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getDrawCanvas()})
      guidesGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:document.getElementById(guidesCanvasId)})
      strokeBufferGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:document.getElementById(strokeBufferCanvasId)})

      let scratchCanvas = document.getElementById(scratchCanvasId)
      if (scratchCanvas)
      {
         scratchGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:scratchCanvas})
         scratchGraphicsEngine.addRenderObject( getScratchGraphics )
      }
      else
      {
         scratchGraphicsEngine = null
      }
   }

   // --------------------------------------------------------------------------
   function reInitGraphicsEngines()
   {
      // TODO : handl these damned things dynamically
      cursorGraphicsEngine.initContext()
      outputGraphicsEngine.initContext()
      guidesGraphicsEngine.initContext()
      strokeBufferGraphicsEngine.initContext()

      if (scratchGraphicsEngine)
      {
         scratchGraphicsEngine.initContext()
      }
   }

   // --------------------------------------------------------------------------
   // INTERFACE UTILITY STUFF
   var numPetalsTimeoutFunc = 0
   function showNumPetals(num)
   {
      $('#numPetalsConfigSpanId').text(num)

      $('#numPetalsSpanId').html(num)
      $('#numPetalsSpanId').addClass('shown')
      if (numPetalsTimeoutFunc != 0)
      {
         clearTimeout(numPetalsTimeoutFunc);
      }
      numPetalsTimeoutFunc = setTimeout(function(){ $('#numPetalsSpanId.shown').removeClass('shown').addClass('transparent') }, 1000);
   }

   var drawModeSpanTimeoutFunc = 0
   function showDrawMode(drawMode)
   {
      $('#drawModeSpanId').text(drawMode)

      $('#drawModeMenuImgId')[0].src = `assets/${drawMode}.png`

      // $('#numPetalsSpanId').html(num)
      $('#drawModeSpanId').addClass('shown')
      if (numPetalsTimeoutFunc != 0)
      {
         clearTimeout(numPetalsTimeoutFunc);
      }
      numPetalsTimeoutFunc = setTimeout(function(){ $('#drawModeSpanId.shown').removeClass('shown').addClass('transparent') }, 500);
   }

   // --------------------------------------------------------------------------
   function toggleMirroring()
   {
      mirrorGuides.set( !mandala.mirrorGuides )

      if ( false == mandala.mirrorGuides )
      {
         mandala.mirrorLine = null

         debugDiv.remove('mirrorLine1')
         debugDiv.remove('mirrorLine2')
      }
      else
      {
         point = toMandalaSpace(drawEngine.cursorCoords)
         // select closest guide line
         mirrorLine = mandala.NearestGuideLine(point)
         mandala.setMirrorLine( mirrorLine )
      }

      $('#mirrorGuidesCheckboxId')[0].checked = mandala.mirrorGuides

      renderCursorGraphics()
   }

   // --------------------------------------------------------------------------
   function toggleShowGuides()
   {
      drawGuides.set( !mandala.drawGuides ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
      $('#showGuidesCheckboxId')[0].checked = mandala.drawGuides
      renderGuides()
   }

   // --------------------------------------------------------------------------
   function toggleHalfGuides()
   {
      drawHalfGuides.set( !mandala.drawHalfGuides ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
      $('#halfGuidesCheckboxId')[0].checked = mandala.drawHalfGuides
      renderGuides()
   }

   // --------------------------------------------------------------------------
   // function onWheel(event)
   // {
   //    console.log(`wheel detail:${event.originalEvent.detail}`)
   // }
   // --------------------------------------------------------------------------
   function activateSnapMode(active)
   {
      snapModeActive = active

      scratchGraphicsEngine.render()
   }

   // --------------------------------------------------------------------------
   function bodyOnKeyDown(event)
   {
      switch (event.originalEvent.key)
      {
         case 'Control':
            activateSnapMode(true)
         break;
      }
   }

   // --------------------------------------------------------------------------
   function bodyOnKeyUp(event)
   {
      switch (event.originalEvent.key)
      {
         case 'Control':
         activateSnapMode(false)
         break;
         case ' ':
            let i = 0
            for (i = 0; i < drawModeNames.length; i += 1)
            {
               if (drawEngine.currentDrawMode.name === drawModeNames[i])
               {
                  let nextModeIndex = (i + 1) % drawModeNames.length
                  onChangeDrawMode(drawModeNames[nextModeIndex])
                  break
               }
            }
         break;
         case 'x':
         case 'X':
            eraseAll()
         break;
         case '<':
         case ',':
            onHalvePetalsButton()
         break;
         case '>':
         case '.':
            onDoublePetalsButton()
         break
         case 'm':
         case 'M':
            toggleMirroring()
         break
         case 'h':
         case 'H':
            toggleHalfGuides()
         break
         case 'g':
         case 'G':
            toggleShowGuides()
         break;
         case 'u':
         case 'U':
            undo()
         break;
         case 'v':
         case 'V':
            viewMandala()
         break;
         case "Escape":
            dismissConfigMenus()
         break;
      }
   }

   // --------------------------------------------------------------------------
   // SETUP
   // --------------------------------------------------------------------------
   var mandala = new Mandala.Mandala()

   var numPetals = WatchedValue.Create(mandala.numPetals,
      [function(value) {   mandala.numPetals = value
                           renderGuides()
                           showNumPetals(value)
                           }])

   var petalsOffset = WatchedValue.Create(mandala.petalsOffset,
      [function(value) {   mandala.petalsOffset = value
                           renderGuides() }])

   var drawHalfGuides = WatchedValue.Create(mandala.drawHalfGuides,
      [ function(value) {  mandala.drawHalfGuides = value
                           renderGuides() }])

   var drawGuides = WatchedValue.Create(mandala.drawGuides,
      [ function(value) {  mandala.drawGuides = value
                           renderGuides() }])

   var mirrorGuides = WatchedValue.Create(mandala.mirrorGuides,
      [ function(value) { mandala.mirrorGuides = value }])

   // ---------------------------------------------------------
   var resizesTimeoutId = null
   function resizesTimeout()
   {
      previousCanWidth = getDrawCanvas().width
      previousCanHeight = getDrawCanvas().height

      // note : resizing should clear
      resizeCanvases()
      reInitGraphicsEngines()

      // Total re-render. Damn, fool. TODO: May need a 'please wait' or something
      // eventually.
      allStrokesBuffer.forEach( function(currentStroke)
      {
         mandala.render(currentStroke, outputGraphicsEngine)
      })

      renderStrokeBuffer(strokeBufferGraphicsEngine, true)

      renderGuides()

      // reset draw engine xlation
      drawEngine.translation = getDrawingCenter().scaleEq(-1)
   }

   // --------------------------------------------------------------------------
   // handlers
   // --------------------------------------------------------------------------
   /*
   // browsers are, for now, only sending resize events when I switch back to
   // tab, so won't deploy this handler just yet, but will leave in place just
   // in case
   var resizeOnVisChange = false
   function onVisibilityChange(isVisible)
   {
      if (isVisible)
      {
         console.log('in main, show')
         if (resizeOnVisChange)
         {
            console.log('need resize...')
            resizeOnVisChange = false
            resizesTimeout()
         }
      }
      else
      {
         console.log('in main, hide')
      }
   }
   */

   // --------------------------------------------------------------------------
   function onBodyResize()
   {
      if (docVisible.isHidden)
      {
         // if I see this log it means I'll have to handle hidden resizes
         console.log(`NOTE: resized while hidden`)
         // resizeOnVisChange = true
      }
      else
      {
         if (resizesTimeoutId)
         {
            clearTimeout(resizesTimeoutId)
         }
         resizesTimeoutId = setTimeout(resizesTimeout, 200)
      }
   }

   // --------------------------------------------------------------------------
   //function onBodyLoad()
   $(document).ready( function()
   {
      createCanvases({canvasOrder})

      // disable right click menu
      $('#cursorCanvasId')[0].oncontextmenu = function(){return false;}
      // TODO: set  opacities dynamically?
      $('#guidesCanvasId')[0].style.opacity = 0.5
      $('#scratchCanvasId')[0].style.opacity = 0.5

      // --- DUCTWORK ---
      // num petals
      let numPetalsRangeCallback = myRangeInput.createRange({id:'numPetalsId',
         containerId:'numPetalsRangeContainer',
         onInputHandler:numPetals.set,
         initialValue:mandala.numPetals,
         min:Mandala.minPetals, max:Mandala.maxPetals, step:1})

      // hook range input up to external changes in num petals value
      numPetals.addSetCallback(numPetalsRangeCallback)

      // petal offset
      let petalsOffsetCB = myRangeInput.createRange({id:'petalsOffsetId',
         containerId:'petalsOffsetRangeContainer',
         onInputHandler:petalsOffset.set,
         initialValue:mandala.petalsOffset,
         min:-0.5, max:0.5, step:0.1})

      // --- graphics setup ---
      initGraphicsEngines()

      snapPointManager = new SnapPointManager.SnapPointManager(snapManagerStripeWidth)
      snapPointManager.addSnapPoint( new fnc2d.Point(0,0), 5, true)

      tempSnapPointManager = new SnapPointManager.SnapPointManager(snapManagerStripeWidth)

      let drawEngineTranslation = getDrawingCenter().scaleEq(-1)
      drawEngine = new DrawEngine.DrawEngine({ inputCanvas:getInputCanvas(),
                                                renderCursorGraphics:renderCursorGraphics,
                                                drawOutputGraphics:drawOutput,
                                                cursorMoveCallback:onCursorMove,
                                                coordsTranslation:drawEngineTranslation,
                                                findSnapPoint:findSnapPoint,
                                                manageTempSnapPoints:manageTempSnapPoints})

      // --- UI INIT ---
      notesLines.forEach( function(currentLine) {
         $newSpan = $(`<span>${currentLine}</span><br>`).toggleClass('notesSpan')
         $('#notesConfigDivId').append($newSpan)
      })

      // TODO: better way to do this?
      $('#drawModeSelectId')[0].value = drawEngine.currentDrawMode.name
      // checkboxes
      $('#halfGuidesCheckboxId')[0].checked = mandala.drawHalfGuides
      $('#showGuidesCheckboxId')[0].checked = mandala.drawGuides
      $('#mirrorGuidesCheckboxId')[0].checked = mandala.mirrorGuides
      $('#numPetalsConfigSpanId').text(mandala.numPetals)

      // initial draw
      renderGuides()

      docVisible.initVisibilityHandling() //onVisibilityChange)

      // color journey stuff
      let colorJourneySpeedCallback = myRangeInput.createRange({id:'colorJourneySpeedId',
            containerId:'colorJourneySpeedContainer',
            onInputHandler:setColorJourneySpeed,
            initialValue:defaultColorJourneyScale,
            min:0, max:1, step:0.01})

      colorJourney = new ColorJourney.ColorJourney({node:document.getElementsByTagName('body')[0],
                                       departureTime:delayBeforeColorJourneyStart,
                                       changePeriod:getColorJourneySpeed(defaultColorJourneyScale)})

      $('body').on('keyup', bodyOnKeyUp)
      $('body').on('keydown', bodyOnKeyDown)
      // $('body').on('mousewheel DOMMouseScroll', onWheel)

      showConfigMenu(`notesConfigDivId`)
   }) // end document.ready

   // ---------------------------------------------------------
   function onClearDrawingButton()
   {
      eraseAll()
   }

   // ---------------------------------------------------------
   function onDoublePetalsButton()
   {
      numPetals.set(Math.min(mandala.numPetals * 2, Mandala.maxPetals))
   }

   // ---------------------------------------------------------
   function onHalvePetalsButton()
   {
      if (mandala.numPetals >= 4)
      {
         numPetals.set(Math.floor(mandala.numPetals / 2))
      }
   }

   // ----------------------------------------------------------------------
   function onPlusOneSpokeButton()
   {
      numPetals.set(Math.min(mandala.numPetals + 1, Mandala.maxPetals))
   }
   function onMinusOneSpokeButton()
   {
      if (mandala.numPetals > 2)
      {
         numPetals.set(mandala.numPetals - 1)
      }
   }

   // -----------------------------------------------------------------------
   function onChangeDrawHalfGuides(event)
   {
      //TODO : check this out in different browsers
      checked = event.target.checked

      drawHalfGuides.set( checked ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
   }

   // -----------------------------------------------------------------------
   function onChangeDrawGuides(event)
   {
      //TODO : check this out in different browsers
      checked = event.target.checked

      drawGuides.set( checked ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
   }

   // -----------------------------------------------------------------------
   function onChangeMirrorGuides(event)
   {
      checked = event.target.checked

      mirrorGuides.set(checked)

      if ( false == mandala.mirrorGuides )
      {
         mandala.mirrorLine = null
      }
   }

   // --------------------------------------------------------------------------
   function onChangeDrawMode(arg)
   {
      if ('object' === typeof arg)
      {
         console.log(`change draw mode to: ${arg.target.value}`)
         showDrawMode(arg.target.value)
         drawEngine.setDrawMode(arg.target.value)
      }
      else if ('string' === typeof arg)
      {
         console.log(`change draw mode to: ${arg}`)
         showDrawMode(arg)
         drawEngine.setDrawMode(arg)
      }
      $('#drawModeSelectId')[0].value = drawEngine.currentDrawMode.name
   }

   // --------------------------------------------------------------------------
   // renders to new canvas, opens in new window as data uri
   // TODO : find better way to do this than giant string?
   function viewMandala()
   {
      let drawCanvas = getDrawCanvas();

      var oldCtx = drawCanvas.getContext('2d')

      var newCanvas = document.createElement('canvas')
      var newCtx = newCanvas.getContext('2d')

      newCanvas.id = 'Mandala'
      newCanvas.width = drawCanvas.width
      newCanvas.height = drawCanvas.height

      // render draw canvas AND stroke buffer
      newCtx.drawImage(getDrawCanvas(), 0, 0)
      newCtx.drawImage($('#strokeBufferCanvasId')[0], 0, 0)

      // var compositeOperation = oldCtx.globalCompositeOperation
      // fill, since canvas has no background
      newCtx.globalCompositeOperation = 'destination-over'
      newCtx.fillStyle = '#FFFFFF'
      newCtx.fillRect(0,0, newCanvas.width, newCanvas.height)

       var dataURL = newCanvas.toDataURL('image/jpeg');

       window.open(dataURL)
   }

   // --------------------------------------------------------------------------
   function onClickViewButton()
   {
      // canvasEl = document.getElementById(drawingCanvasId)
      // this is dumb, for some reason undo and draw buffers don't composite correctly
      viewMandala()
   }

   // --------------------------------------------------------------------------
   function onClickUndoButton()
   {
      undo()
   }

   // --------------------------------------------------------------------------
   function onPlayPauseColorJourneyButton()
   {
      playState = colorJourney.togglePlaying()

      $('#playPauseColorJourneyButtonId')[0].innerHTML = playState ? '||' : ' >'
   }

   // --------------------------------------------------------------------------
   function onNextColorButton()
   {
      colorJourney.nextColor()
   }

   </script>

   <ul id="mainMenuId">
      <!--- TODO : fix this lame ass hardwired initial image, should be driven by mode --->
      <li><img id='drawModeMenuImgId' src='assets/freeform.png' width='25px' height='25px' onclick='showConfigMenu(`drawConfigDivId`)'/></li>
      <li><img src='assets/flower.png' width='25px' height='25px' onclick='showConfigMenu(`petalsConfigDivId`)'/></li>
      <li><img src='assets/colors.png' width='25px' height='25px' onclick='showConfigMenu(`colorsConfigDivId`)'/></li>
   </ul>

   <div id='petalsConfigDivId' class='menu_transparent configDivClass'>
      <span>petals: </span>
      <span id='numPetalsConfigSpanId'></span>
      <button class='dismissButton flatButton' onclick='dismissConfigMenus()'>X</button>
      <br><br>
      <div id='numPetalsRangeContainer' style='display:inline-block;'></div>
      <br>
      <button id='halveSpokesButtonId' class='flatButton' title='half' onclick='onHalvePetalsButton()'>&lt;&lt;</button>
      <button id='PlusOneSpokeButtonId' class='flatButton' title='minus one' onclick='onMinusOneSpokeButton()'>-</button>
      <button id='PlusOneSpokeButtonId' class='flatButton' title='add one' onclick='onPlusOneSpokeButton()'>+</button>
      <button id='doubleSpokesButtonId' class='flatButton' title='double' onclick='onDoublePetalsButton()'>&gt;&gt;</button>
      <br>
      <br>
      <span>offset:</span>
      <br>
      <div id='petalsOffsetRangeContainer' style='display:inline-block;'></div>
      <br>
      <br>
      <span class="highlightletter">m</span><span>irror guides:</span><input type='checkbox' id='mirrorGuidesCheckboxId', checked='false' onchange='onChangeMirrorGuides(event)'>
      <br>
      show <span class="highlightletter">g</span><span>uides :</span><input type='checkbox' id='showGuidesCheckboxId' checked='true' onchange="onChangeDrawGuides(event)">
      <br>
      <span class="highlightletter">h</span><span>alf guides:</span><input type='checkbox' id='halfGuidesCheckboxId' checked='true' onchange="onChangeDrawHalfGuides(event)">
      <br>
      <br><br>
   </div>

   <div id='colorsConfigDivId' class='menu_transparent configDivClass'>
      <span>color journey</span>
      <button class='dismissButton flatButton' onclick='dismissConfigMenus()'>X</button>
      <br><br>
      <button id='playPauseColorJourneyButtonId' class='flatButton' onclick='onPlayPauseColorJourneyButton()'>||</button>
      <button id='nextColorButtonId' class='flatButton' onclick='onNextColorButton()'>&gt;&gt;</button>
      <br>
      <!-- <img src='assets/hslhuecircle.png'/> -->
      <br>
      <span>speed</span>
      <div id='colorJourneySpeedContainer' style='display:inline-block;'></div>
      <br>
   </div>

   <div id='drawConfigDivId' class='menu_transparent configDivClass'>
      <span>drawing</span>
      <button class='dismissButton flatButton' onclick='dismissConfigMenus()'>X</button>
      <br><br>
      <select id='drawModeSelectId' onchange='onChangeDrawMode(event)'>
         <option value='freeform'>freeform</option>
         <option value='curves'>curves</option>
         <option value='lines'>lines</option>
         <option value='circles'>circles</option>
      </select>
      <br>
      <button id='undoButtonId' class='flatButton' onclick='onClickUndoButton()'><span class='highlightletter'>u</span>ndo</button>
      <br>
      <button id='clearDrawingButtonId' class='flatButton' onclick='onClearDrawingButton()'>clear (<span class='highlightletter'>X</span>)</button>
      <br>
      <button id='viewButtonId' class='flatButton' onclick='onClickViewButton()'><span class='highlightletter'>v</span>iew</button>
      <br>
      <br>
      <button id='showNotesButtonId' class='flatButton' onclick='showConfigMenu(`notesConfigDivId`)'>notes</button>
   </div>

   <div id='notesConfigDivId' class='menu_transparent configDivClass'>
      <span>notes</span>
      <button class='dismissButton flatButton' onclick='dismissConfigMenus()'>X</button>
      <br>
      <br>
   </div>

   <span id='numPetalsSpanId' class='overlayText transparent'></span>
   <span id='drawModeSpanId' class='overlayText transparent'></span>

   <div id="canvasContainerId">
   </div>

</body>
